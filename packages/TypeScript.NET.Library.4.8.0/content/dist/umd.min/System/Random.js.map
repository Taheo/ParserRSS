{"version":3,"sources":["System/Random.js","System/Random.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Object","defineProperty","value","Random","Integer_1","initialize_1","shuffle_1","assert","Integer","r","maxExclusive","Math","floor","random","nr","boundary","inclusive","a","abs","arrayCopy","source","len","length","result","initialize","i","integer","next","integers","count","s","shuffle","target","copy","select","maxCount","Infinity","assertZeroOrGreater","one","float","Number","MAX_VALUE","isNaN","inRange","min","max","range","throwIfEmpty"],"mappings":"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","file":"Random.js","sourcesContent":["(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./Integer\", \"./Collections/Array/initialize\", \"./Collections/Array/shuffle\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /*!\n     * @author electricessence / https://github.com/electricessence/\n     * Licensing: MIT\n     */\n    var Integer_1 = require(\"./Integer\");\n    var initialize_1 = require(\"./Collections/Array/initialize\");\n    var shuffle_1 = require(\"./Collections/Array/shuffle\");\n    var assert = Integer_1.Integer.assert;\n    var Random;\n    (function (Random) {\n        function r(maxExclusive) {\n            return Math.floor(Math.random() * maxExclusive);\n        }\n        function nr(boundary, inclusive) {\n            var a = Math.abs(boundary);\n            if (a === 0 || a === 1 && !inclusive)\n                return 0;\n            if (inclusive)\n                boundary += boundary / a;\n            return r(boundary);\n        }\n        function arrayCopy(source) {\n            var len = source.length;\n            var result = initialize_1.initialize(len);\n            for (var i = 0; i < len; i++) {\n                result[i] = source[i];\n            }\n            return result;\n        }\n        /**\n         * Returns a random integer from 0 to the maxExclusive.\n         * Negative numbers are allowed.\n         *\n         * @param maxExclusive\n         * @returns {number}\n         */\n        function integer(maxExclusive) {\n            return next(maxExclusive);\n        }\n        Random.integer = integer;\n        /**\n         * Returns a random integer from 0 to the boundary.\n         * Return value will be less than the boundary unless inclusive is set to true.\n         * Negative numbers are allowed.\n         *\n         * @param boundary\n         * @param inclusive\n         * @returns {number}\n         */\n        function next(boundary, inclusive) {\n            assert(boundary, 'boundary');\n            return nr(boundary, inclusive);\n        }\n        Random.next = next;\n        (function (next) {\n            function integer(boundary, inclusive) {\n                return Random.next(boundary, inclusive);\n            }\n            next.integer = integer;\n            function float(boundary) {\n                if (boundary === void 0) { boundary = Number.MAX_VALUE; }\n                if (isNaN(boundary))\n                    throw \"'boundary' is not a number.\";\n                return Math.random() * boundary;\n            }\n            next.float = float;\n            function inRange(min, max, inclusive) {\n                assert(min, 'min');\n                assert(max, 'max');\n                var range = max - min;\n                if (range === 0)\n                    return min;\n                if (inclusive)\n                    range += range / Math.abs(range);\n                return min + r(range);\n            }\n            next.inRange = inRange;\n        })(next = Random.next || (Random.next = {}));\n        /**\n         * Returns an array of random integers.\n         * @param count\n         * @param boundary\n         * @param inclusive\n         * @returns {number[]}\n         */\n        function integers(count, boundary, inclusive) {\n            assert(count);\n            var s = [];\n            s.length = count;\n            for (var i = 0; i < count; i++) {\n                s[i] = nr(boundary, inclusive);\n            }\n            return s;\n        }\n        Random.integers = integers;\n        /**\n         * Shuffles an array.\n         * @param target\n         * @returns {T}\n         */\n        function shuffle(target) {\n            return shuffle_1.shuffle(target);\n        }\n        Random.shuffle = shuffle;\n        /**\n         * Creates a copy of an array-like  and returns it shuffled.\n         * @param source\n         * @returns {T[]}\n         */\n        function copy(source) {\n            return shuffle_1.shuffle(arrayCopy(source));\n        }\n        Random.copy = copy;\n        /**\n         * Returns a distinct random set from the source array up to the maxCount or the full length of the array.\n         * @param source\n         * @param maxCount\n         * @returns {any}\n         */\n        function select(source, maxCount) {\n            if (maxCount !== Infinity)\n                Integer_1.Integer.assertZeroOrGreater(maxCount);\n            switch (maxCount) {\n                case 0:\n                    return [];\n                case 1:\n                    return [select.one(source, true)];\n                default:\n                    var result = shuffle_1.shuffle(arrayCopy(source));\n                    if (maxCount < result.length)\n                        result.length = maxCount;\n                    return result;\n            }\n        }\n        Random.select = select;\n        (function (select) {\n            function one(source, throwIfEmpty) {\n                if (source && source.length)\n                    return source[r(source.length)];\n                if (throwIfEmpty)\n                    throw \"Cannot select from an empty set.\";\n            }\n            select.one = one;\n        })(select = Random.select || (Random.select = {}));\n    })(Random = exports.Random || (exports.Random = {}));\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\nimport {Integer} from \"./Integer\";\r\nimport {initialize} from \"./Collections/Array/initialize\";\r\nimport {shuffle as arrayShuffle} from \"./Collections/Array/shuffle\";\r\nimport {ArrayLikeWritable} from \"./Collections/Array/ArrayLikeWritable\";\r\nimport assert = Integer.assert;\r\n\r\nexport module Random\r\n{\r\n\r\n\tfunction r(maxExclusive:number):number\r\n\t{\r\n\t\treturn Math.floor(Math.random()*maxExclusive);\r\n\t}\r\n\r\n\tfunction nr(\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number\r\n\t{\r\n\t\tconst a = Math.abs(boundary);\r\n\t\tif(a===0 || a===1 && !inclusive) return 0;\r\n\t\tif(inclusive) boundary += boundary/a;\r\n\t\treturn r(boundary);\r\n\t}\r\n\r\n\tfunction arrayCopy<T>(source:ArrayLike<T>):T[]\r\n\t{\r\n\t\tconst len = source.length;\r\n\t\tconst result = initialize<T>(len);\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tresult[i] = source[i];\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random integer from 0 to the maxExclusive.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param maxExclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function integer(maxExclusive:number):number\r\n\t{\r\n\t\treturn next(maxExclusive);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a random integer from 0 to the boundary.\r\n\t * Return value will be less than the boundary unless inclusive is set to true.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param boundary\r\n\t * @param inclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function next(\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number\r\n\t{\r\n\t\tassert(boundary, 'boundary');\r\n\t\treturn nr(boundary, inclusive);\r\n\t}\r\n\r\n\texport module next\r\n\t{\r\n\t\texport function integer(\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\treturn Random.next(boundary, inclusive);\r\n\t\t}\r\n\r\n\t\texport function float(boundary:number = Number.MAX_VALUE):number\r\n\t\t{\r\n\t\t\tif(isNaN(boundary))\r\n\t\t\t\tthrow \"'boundary' is not a number.\";\r\n\t\t\treturn Math.random()*boundary;\r\n\t\t}\r\n\r\n\t\texport function inRange(\r\n\t\t\tmin:number,\r\n\t\t\tmax:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\tassert(min, 'min');\r\n\t\t\tassert(max, 'max');\r\n\t\t\tlet range = max - min;\r\n\t\t\tif(range===0) return min;\r\n\t\t\tif(inclusive) range += range/Math.abs(range);\r\n\t\t\treturn min + r(range);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns an array of random integers.\r\n\t * @param count\r\n\t * @param boundary\r\n\t * @param inclusive\r\n\t * @returns {number[]}\r\n\t */\r\n\texport function integers(\r\n\t\tcount:number,\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number[]\r\n\t{\r\n\t\tassert(count);\r\n\t\tconst s:number[] = [];\r\n\t\ts.length = count;\r\n\t\tfor(let i = 0; i<count; i++)\r\n\t\t{\r\n\t\t\ts[i] = nr(boundary, inclusive);\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\r\n\t/**\r\n\t * Shuffles an array.\r\n\t * @param target\r\n\t * @returns {T}\r\n\t */\r\n\texport function shuffle<T extends ArrayLikeWritable<any>>(target:T):T\r\n\t{\r\n\t\treturn arrayShuffle(target);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a copy of an array-like  and returns it shuffled.\r\n\t * @param source\r\n\t * @returns {T[]}\r\n\t */\r\n\texport function copy<T>(source:ArrayLike<T>):T[]\r\n\t{\r\n\t\treturn arrayShuffle(arrayCopy(source));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a distinct random set from the source array up to the maxCount or the full length of the array.\r\n\t * @param source\r\n\t * @param maxCount\r\n\t * @returns {any}\r\n\t */\r\n\texport function select<T>(source:ArrayLike<T>, maxCount:number):T[]\r\n\t{\r\n\t\tif(maxCount!==Infinity) Integer.assertZeroOrGreater(maxCount);\r\n\t\tswitch (maxCount) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn [];\r\n\t\t\tcase 1:\r\n\t\t\t\treturn [select.one(source, true)];\r\n\t\t\tdefault:\r\n\t\t\t\tlet result = arrayShuffle(arrayCopy(source));\r\n\t\t\t\tif(maxCount<result.length)\r\n\t\t\t\t\tresult.length = maxCount;\r\n\t\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\texport module select\r\n\t{\r\n\t\t/**\r\n\t\t * Returns random value from an array.\r\n\t\t * @param source\r\n\t\t * @param throwIfEmpty\r\n\t\t */\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty:true):T\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty?:boolean):T|undefined\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty?:boolean):T|undefined\r\n\t\t{\r\n\t\t\tif(source && source.length)\r\n\t\t\t\treturn source[r(source.length)];\r\n\r\n\t\t\tif(throwIfEmpty)\r\n\t\t\t\tthrow \"Cannot select from an empty set.\";\r\n\t\t}\r\n\t}\r\n}"]}