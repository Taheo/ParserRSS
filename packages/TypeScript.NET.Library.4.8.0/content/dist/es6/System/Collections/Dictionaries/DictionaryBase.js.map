{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.ts"],"names":[],"mappings":"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","file":"DictionaryBase.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {areEqual} from \"../../Compare\";\r\nimport {forEach} from \"../Enumeration/Enumerator\";\r\nimport {CollectionBase} from \"../CollectionBase\";\r\nimport {EnumeratorBase} from \"../Enumeration/EnumeratorBase\";\r\nimport {ArgumentNullException} from \"../../Exceptions/ArgumentNullException\";\r\nimport {InvalidOperationException} from \"../../Exceptions/InvalidOperationException\";\r\nimport {extractKeyValue} from \"../../KeyValueExtract\";\r\nimport {IKeyValuePair, KeyValuePair} from \"../../KeyValuePair\";\r\nimport {IDictionary} from \"./IDictionary\";\r\nimport {IEnumerator} from \"../Enumeration/IEnumerator\";\r\nimport {IEnumerableOrArray} from \"../IEnumerableOrArray\";\r\nimport __extendsImport from \"../../../extends\";\r\nimport {KeyNotFoundException} from \"../KeyNotFoundException\";\r\nimport {Action} from \"../../FunctionTypes\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nexport abstract class DictionaryBase<TKey, TValue>\r\nextends CollectionBase<IKeyValuePair<TKey,TValue>> implements IDictionary<TKey, TValue>\r\n{\r\n\tconstructor(source?:IEnumerableOrArray<IKeyValuePair<TKey,TValue>>)\r\n\t{\r\n\t\tsuper(source);\r\n\t}\r\n\r\n\r\n\t//noinspection JSUnusedLocalSymbols\r\n\tprotected _onValueModified(key:TKey, value:TValue|undefined, old:TValue|undefined):void\r\n\t{\r\n\t}\r\n\r\n\tprotected _addInternal(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) => this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet count = 0;\r\n\r\n\t\tfor(let key of _.keys)\r\n\t\t{\r\n\t\t\tif(_.removeByKey(key)) count++;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item || !this.getCount()) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) =>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tprotected _removeInternal(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value) =>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot add 'undefined' as a value.\");\r\n\r\n\t\tconst _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tconst ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\treturn _.setValue(key, value);\r\n\t}\r\n\r\n\tprotected abstract _getEntry(key:TKey):IKeyValuePair<TKey,TValue>|null;\r\n\r\n\tabstract getValue(key:TKey):TValue|undefined;\r\n\r\n\tgetAssuredValue(key:TKey):TValue\r\n\t{\r\n\t\tconst value = this.getValue(key);\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new KeyNotFoundException(`Key '${key}' not found.`);\r\n\t\treturn value;\r\n\t}\r\n\r\n\ttryGetValue(key:TKey, out:Action<TValue>):boolean\r\n\t{\r\n\t\tconst value = this.getValue(key);\r\n\t\tif(value!==VOID0)\r\n\t\t{\r\n\t\t\tout(value);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected abstract _setValueInternal(key:TKey, value:TValue|undefined):boolean;\r\n\r\n\t/**\r\n\t * Sets the value of an entry.\r\n\t * It's important to know that 'undefined' cannot exist as a value in the dictionary and is used as a flag for removal.\r\n\t * @param key\r\n\t * @param value\r\n\t * @returns {boolean}\r\n\t */\r\n\tsetValue(key:TKey, value:TValue|undefined):boolean\r\n\t{\r\n\t\t// setValue shouldn't need to worry about recursion...\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\r\n\t\tlet changed = false;\r\n\t\tconst old = _.getValue(key); // get the old value here and pass to internal.\r\n\t\tif(!areEqual(value, old) && _._setValueInternal(key, value))\r\n\t\t{\r\n\t\t\tchanged = true;\r\n\t\t\t_._onValueModified(key, value, old)\r\n\t\t}\r\n\r\n\t\t_._signalModification(changed);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\treturn !!this._getEntry(key);\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tconst e = this.getEnumerator();\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(areEqual(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, VOID0);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet count = 0;\r\n\t\tfor(let key of _.getKeys())\r\n\t\t{\r\n\t\t\tif(areEqual(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>|IEnumerator<KeyValuePair<TKey, TValue>>|null|undefined):number\r\n\t{\r\n\t\t// Allow piping through to trigger onModified properly.\r\n\t\treturn super.importEntries(<any>pairs);\r\n\t}\r\n\r\n\tprotected _importEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>|IEnumerator<KeyValuePair<TKey, TValue>>|null|undefined):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tif(!pairs) return 0;\r\n\t\tlet changed:number = 0;\r\n\t\tforEach(pairs,\r\n\t\t\tpair => extractKeyValue(pair, (key, value) =>\r\n\t\t\t{\r\n\t\t\t\tif(_._setValueInternal(key, value))\r\n\t\t\t\t\tchanged++;\r\n\t\t\t})\r\n\t\t);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet ver:number, keys:TKey[], len:number, index = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\tver = _._version; // Track the version since getKeys is a copy.\r\n\t\t\t\tkeys = _.getKeys();\r\n\t\t\t\tlen = keys.length;\r\n\t\t\t},\r\n\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\t_.assertVersion(ver);\r\n\r\n\t\t\t\twhile(index<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tconst key = keys[index++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;"]}