{"version":3,"sources":["System/Collections/Array/Compare.ts"],"names":[],"mappings":"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","file":"Compare.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport * as Values from \"../../Compare\";\r\nimport {Type} from \"../../Types\";\r\nimport {Primitive} from \"../../Primitive\";\r\nimport {EqualityComparison, Comparison} from \"../../FunctionTypes\";\r\nimport {IComparable} from \"../../IComparable\";\r\n\r\n/*  validateSize: Utility for quick validation/invalidation of array equality.\r\n\tWhy this way?  Why not pass a closure for the last return?\r\n\tReason: Performance and avoiding the creation of new functions/closures. */\r\nfunction validateSize(a:ArrayLike<any>, b:ArrayLike<any>):boolean|number\r\n{\r\n\t// Both valid and are same object, or both are null/undefined.\r\n\tif(a && b && a===b || !a && !b)\r\n\t\treturn true;\r\n\r\n\t// At this point, at least one has to be non-null.\r\n\tif(!a || !b)\r\n\t\treturn false;\r\n\r\n\tconst len = a.length;\r\n\tif(len!==b.length)\r\n\t\treturn false;\r\n\r\n\t// If both are arrays and have zero length, they are equal.\r\n\tif(len===0)\r\n\t\treturn true;\r\n\r\n\t// Return the length for downstream processing.\r\n\treturn len;\r\n}\r\n\r\nexport function areAllEqual(\r\n\tarrays:ArrayLike<ArrayLike<any>>,\r\n\tequalityComparer?:EqualityComparison<any>):boolean\r\nexport function areAllEqual(\r\n\tarrays:ArrayLike<ArrayLike<any>>,\r\n\tstrict:boolean,\r\n\tequalityComparer?:EqualityComparison<any>):boolean\r\nexport function areAllEqual(\r\n\tarrays:ArrayLike<ArrayLike<any>>,\r\n\tstrict:boolean|EqualityComparison<any> = true,\r\n\tequalityComparer:EqualityComparison<any> = Values.areEqual):boolean\r\n{\r\n\tif(!arrays)\r\n\t\tthrow new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\r\n\tif(arrays.length<2)\r\n\t\tthrow new Error(\"Cannot compare a set of arrays less than 2.\");\r\n\r\n\tif(Type.isFunction(strict)) {\r\n\t\tequalityComparer = strict;\r\n\t\tstrict = true;\r\n\t}\r\n\r\n\tconst first = arrays[0];\r\n\tfor(let i = 1, l = arrays.length; i<l; i++)\r\n\t{\r\n\t\tif(!areEqual(first, arrays[i], strict, equalityComparer))\r\n\t\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n/**\r\n * Compares two arrays for equality.\r\n * @param a\r\n * @param b\r\n * @param equalityComparer\r\n */\r\nexport function areEqual<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tequalityComparer?:EqualityComparison<T>):boolean\r\nexport function areEqual<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tstrict:boolean,\r\n\tequalityComparer?:EqualityComparison<T>):boolean\r\nexport function areEqual<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tstrict:boolean|EqualityComparison<T> = true,\r\n\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n{\r\n\tconst len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\tif(Type.isFunction(strict)) {\r\n\t\tequalityComparer = strict;\r\n\t\tstrict = true;\r\n\t}\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(!equalityComparer(a[i], b[i], strict))\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction internalSort<T>(a:ArrayLike<T>, comparer:Comparison<T>):ArrayLike<T>\r\n{\r\n\tif(!a || a.length<2) return a;\r\n\r\n\tconst len = a.length;\r\n\tlet b:T[];\r\n\tif(len>65536)\r\n\t\tb = new Array(len);\r\n\telse\r\n\t{\r\n\t\tb = [];\r\n\t\tb.length = len;\r\n\t}\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tb[i] = a[i];\r\n\t}\r\n\r\n\tb.sort(comparer);\r\n\treturn b;\r\n}\r\n\r\nexport function areEquivalent<T extends Primitive>(a:ArrayLike<T>, b:ArrayLike<T>):boolean;\r\nexport function areEquivalent<T>(a:ArrayLike<IComparable<T>>, b:ArrayLike<IComparable<T>>):boolean;\r\nexport function areEquivalent<T>(a:ArrayLike<T>, b:ArrayLike<T>, comparer:Comparison<T>):boolean;\r\nexport function areEquivalent<T>(\r\n\ta:ArrayLike<T>, b:ArrayLike<T>,\r\n\tcomparer:Comparison<T> = Values.compare):boolean\r\n{\r\n\tconst len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\t// There might be a better more performant way to do this, but for the moment, this\r\n\t// works quite well.\r\n\ta = internalSort(a, comparer);\r\n\tb = internalSort(b, comparer);\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(comparer(a[i], b[i])!==0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n"]}