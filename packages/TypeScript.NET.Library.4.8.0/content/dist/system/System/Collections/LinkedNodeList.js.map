{"version":3,"sources":["System/Collections/LinkedNodeList.ts"],"names":[],"mappings":"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","file":"LinkedNodeList.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {format} from \"../Text/Utility\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {EnumeratorBase} from \"./Enumeration/EnumeratorBase\";\r\nimport {ILinkedNode, ILinkedNodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerateEach} from \"./Enumeration/IEnumerateEach\";\r\nimport {IDisposable} from \"../Disposable/IDisposable\";\r\nimport {ILinkedNodeList} from \"./ILinkedList\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {Selector, PredicateWithIndex, ActionWithIndex, SelectorWithIndex} from \"../FunctionTypes\";\r\nimport {ArrayLikeWritable} from \"./Array/ArrayLikeWritable\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/**\r\n * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\r\n * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\r\n *\r\n * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\r\n * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\r\n *\r\n * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\r\n */\r\nexport class LinkedNodeList<TNode extends ILinkedNode<TNode>>\r\nimplements ILinkedNodeList<TNode>, IEnumerateEach<TNode>, IDisposable\r\n{\r\n\r\n\tprivate _first:TNode|null;\r\n\tprivate _last:TNode|null;\r\n\tunsafeCount:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._first = null;\r\n\t\tthis._last = null;\r\n\t\tthis.unsafeCount = 0;\r\n\t\tthis._version = 0;\r\n\t}\r\n\r\n\tprivate _version:number;\r\n\r\n\tassertVersion(version:number):true|never\r\n\t{\r\n\t\tif(version!==this._version)\r\n\t\t\tthrow new InvalidOperationException(\"Collection was modified.\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * The first node.  Will be null if the collection is empty.\r\n\t */\r\n\tget first():TNode|null\r\n\t{\r\n\t\treturn this._first;\r\n\t}\r\n\r\n\t/**\r\n\t * The last node.\r\n\t */\r\n\tget last():TNode|null\r\n\t{\r\n\t\treturn this._last;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iteratively counts the number of linked nodes and returns the value.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\r\n\t\tlet next:TNode|null|undefined = this._first;\r\n\r\n\t\tlet i:number = 0;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t// Note, no need for 'useCopy' since this avoids any modification conflict.\r\n\t// If iterating over a arrayCopy is necessary, a arrayCopy should be made manually.\r\n\tforEach(\r\n\t\taction:ActionWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\tforEach(\r\n\t\taction:PredicateWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\tforEach(\r\n\t\taction:ActionWithIndex<TNode> | PredicateWithIndex<TNode>, ignoreVersioning?:boolean):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet current:TNode|null|undefined = null,\r\n\t\t    next:TNode|null|undefined = _.first; // Be sure to track the next node so if current node is removed.\r\n\r\n\t\tconst version = _._version;\r\n\t\tlet index:number = 0;\r\n\t\tdo {\r\n\t\t\tif(!ignoreVersioning) _.assertVersion(version);\r\n\t\t\tcurrent = next;\r\n\t\t\tnext = current && current.next;\r\n\t\t}\r\n\t\twhile(current\r\n\t\t&& <any>action(current, index++)!==false);\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\tmap<T>(selector:Selector<TNode,T>):T[]\r\n\tmap<T>(selector:SelectorWithIndex<TNode,T>):T[]\r\n\tmap<T>(selector:SelectorWithIndex<TNode,T>):T[]\r\n\t{\r\n\t\tif(!selector) throw new ArgumentNullException('selector');\r\n\r\n\t\tconst result:T[] = [];\r\n\t\tthis.forEach((node, i)=>\r\n\t\t{\r\n\t\t\tresult.push(selector(node, i));\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the linked node's references to each other and returns the number of nodes.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet n:TNode|null|undefined, cF:number = 0, cL:number = 0;\r\n\r\n\t\t// First, clear in the forward direction.\r\n\t\tn = _._first;\r\n\t\t_._first = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcF++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.next;\r\n\t\t\tcurrent.next = null;\r\n\t\t}\r\n\r\n\t\t// Last, clear in the reverse direction.\r\n\t\tn = _._last;\r\n\t\t_._last = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcL++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.previous;\r\n\t\t\tcurrent.previous = null;\r\n\t\t}\r\n\r\n\t\tif(cF!==cL) console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing. Forward: ' + cF + \", Reverse: \" + cL);\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount = 0;\r\n\r\n\t\treturn cF;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the list.\r\n\t */\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to see if a node exists.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontains(node:TNode):boolean\r\n\t{\r\n\t\treturn this.indexOf(node)!= -1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the index of a particular node.\r\n\t * @param index\r\n\t */\r\n\tgetNodeAt(index:number):TNode|null\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\treturn null;\r\n\r\n\t\tlet next = this._first;\r\n\r\n\t\tlet i:number = 0;\r\n\t\twhile(next && i++<index)\r\n\t\t{\r\n\t\t\tnext = next.next || null;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tfind(condition:PredicateWithIndex<TNode>):TNode|null\r\n\t{\r\n\t\tlet node:TNode|null = null;\r\n\t\tthis.forEach((n, i)=>\r\n\t\t{\r\n\t\t\tif(condition(n, i))\r\n\t\t\t{\r\n\t\t\t\tnode = n;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to find the specified node and returns its index.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tindexOf(node:TNode):number\r\n\t{\r\n\t\tif(node && (node.previous || node.next))\r\n\t\t{\r\n\r\n\t\t\tlet index = 0;\r\n\t\t\tlet c:TNode|null|undefined,\r\n\t\t\t    n:TNode|null|undefined = this._first;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tc = n;\r\n\t\t\t\tif(c===node) return index;\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\twhile((n = c && c.next));\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the first node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\treturn !!this._first && this.removeNode(this._first);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveLast():boolean\r\n\t{\r\n\t\treturn !!this._last && this.removeNode(this._last);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the specified node.\r\n\t * Returns true if successful and false if not found (already removed).\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveNode(node:TNode):boolean\r\n\t{\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tconst _ = this;\r\n\t\tconst prev:TNode|null = node.previous || null,\r\n\t\t      next:TNode|null = node.next || null;\r\n\r\n\t\tlet a:boolean = false,\r\n\t\t    b:boolean = false;\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==node) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.previous = prev;\r\n\t\telse if(_._last==node) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tconst removed = !a && !b;\r\n\t\tif(removed)\r\n\t\t{\r\n\t\t\t_._version++;\r\n\t\t\t_.unsafeCount--;\r\n\t\t\tnode.previous = null;\r\n\t\t\tnode.next = null;\r\n\t\t}\r\n\t\treturn removed;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a node to the end of the list.\r\n\t * @param node\r\n\t */\r\n\taddNode(node:TNode):void\r\n\t{\r\n\t\tthis.addNodeAfter(node);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Inserts a node before the specified 'before' node.\r\n\t * If no 'before' node is specified, it inserts it as the first node.\r\n\t * @param node\r\n\t * @param before\r\n\t */\r\n\taddNodeBefore(node:TNode, before:TNode|null = null):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!before)\r\n\t\t{\r\n\t\t\tbefore = _._first;\r\n\t\t}\r\n\r\n\t\tif(before)\r\n\t\t{\r\n\t\t\tlet prev = before.previous;\r\n\t\t\tnode.previous = prev;\r\n\t\t\tnode.next = before;\r\n\r\n\t\t\tbefore.previous = node;\r\n\t\t\tif(prev) prev.next = node;\r\n\t\t\tif(before==_._first) _._first = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount++;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node after the specified 'after' node.\r\n\t * If no 'after' node is specified, it appends it as the last node.\r\n\t * @param node\r\n\t * @param after\r\n\t */\r\n\taddNodeAfter(node:TNode, after:TNode|null = null):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!after)\r\n\t\t{\r\n\t\t\tafter = _._last;\r\n\t\t}\r\n\r\n\t\tif(after)\r\n\t\t{\r\n\t\t\tlet next = after.next;\r\n\t\t\tnode.next = next;\r\n\t\t\tnode.previous = after;\r\n\r\n\t\t\tafter.next = node;\r\n\t\t\tif(next) next.previous = node;\r\n\t\t\tif(after==_._last) _._last = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_._version++;\r\n\t\t_.unsafeCount++;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Takes and existing node and replaces it.\r\n\t * @param node\r\n\t * @param replacement\r\n\t */\r\n\treplace(node:TNode, replacement:TNode):void\r\n\t{\r\n\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tif(node==replacement) return;\r\n\r\n\t\tassertValidDetached(replacement, 'replacement');\r\n\r\n\t\tconst _ = this;\r\n\t\treplacement.previous = node.previous;\r\n\t\treplacement.next = node.next;\r\n\r\n\t\tif(node.previous) node.previous.next = replacement;\r\n\t\tif(node.next) node.next.previous = replacement;\r\n\r\n\t\tif(node==_._first) _._first = replacement;\r\n\t\tif(node==_._last) _._last = replacement;\r\n\r\n\t\t_._version++;\r\n\t}\r\n\r\n\tstatic valueEnumeratorFrom<T>(list:LinkedNodeList<ILinkedNodeWithValue<T>>):IEnumerator<T>\r\n\t{\r\n\r\n\t\tif(!list) throw new ArgumentNullException('list');\r\n\r\n\t\tlet current:ILinkedNodeWithValue<T>|null|undefined,\r\n\t\t    next:ILinkedNodeWithValue<T>|null|undefined,\r\n\t\t    version:number;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Initialize anchor...\r\n\t\t\t\tcurrent = null;\r\n\t\t\t\tnext = list.first;\r\n\t\t\t\tversion = list._version;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\tif(next)\r\n\t\t\t\t{\r\n\t\t\t\t\tlist.assertVersion(version);\r\n\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current && current.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(current.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic copyValues<T,TDestination extends ArrayLikeWritable<any>>(\r\n\t\tlist:LinkedNodeList<ILinkedNodeWithValue<T>>,\r\n\t\tarray:TDestination,\r\n\t\tindex:number = 0):TDestination\r\n\t{\r\n\t\tif(list && list.first)\r\n\t\t{\r\n\t\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t\tlist.forEach(\r\n\t\t\t\t(node, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tarray[index + i] = node.value;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n}\r\n\r\nfunction assertValidDetached<TNode extends ILinkedNode<TNode>>(\r\n\tnode:TNode,\r\n\tpropName:string = 'node')\r\n{\r\n\r\n\tif(node==null)\r\n\t\tthrow new ArgumentNullException(propName);\r\n\r\n\tif(node.next || node.previous)\r\n\t\tthrow new InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\r\n\r\n}\r\n\r\nexport default LinkedNodeList;"]}