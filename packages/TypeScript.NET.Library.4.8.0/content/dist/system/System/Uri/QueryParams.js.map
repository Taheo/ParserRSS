{"version":3,"sources":["System/Uri/QueryParams.ts"],"names":[],"mappings":";;;IA4BA;;;;;OAKG;IACH,gBACC,MAAsD,EACtD,gBAAyB;QAEzB,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC;YAAC,MAAM,CAAC,KAAK,CAAC;QACzB,IAAM,OAAO,GAAY,EAAE,CAAC;QAE5B,EAAE,CAAA,CAAC,oCAAuB,CAAC,MAAM,CAAC,CAAC,CACnC,CAAC;YACA,oBAAO,CAAC,MAAM,EAAE,UAAA,KAAK;gBACpB,OAAA,iCAAe,CAAC,KAAK,EACpB,UAAC,GAAG,EAAE,KAAK,IAAI,OAAA,cAAc,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,EAAnC,CAAmC,CAAC;YADpD,CACoD,CACpD,CAAC;QACH,CAAC;QACD,IAAI,CACJ,CAAC;YACA,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,OAAO,CAC1B,UAAA,GAAG,IAAG,OAAA,cAAc,CAAC,OAAO,EAAE,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAzC,CAAyC,CAC/C,CAAC;QACH,CAAC;QAED,MAAM,CAAC,CAAC,OAAO,CAAC,MAAM,IAAI,gBAAgB,GAAG,eAAe,GAAG,KAAK,CAAC;cAClE,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;IAClC,CAAC;;IAED,8BACC,OAAgB,EAChB,GAAU,EACV,KAAwB;QAExB,OAAO,CAAC,IAAI,CAAC,GAAG,GAAG,mBAAmB,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;IAC9D,CAAC;IAED,oHAAoH;IACpH,wBACC,OAAgB,EAChB,GAAU,EACV,KAA+D;QAE/D,EAAE,CAAA,CAAC,oCAAuB,CAAC,KAAK,CAAC,CAAC,CAClC,CAAC;YACA,oBAAO,CAAC,KAAK,EAAE,UAAA,CAAC,IAAG,OAAA,oBAAoB,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC,EAArC,CAAqC,CAAC,CAAC;QAC3D,CAAC;QACD,IAAI,CACJ,CAAC;YACA,oBAAoB,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,CAAA;QAC1C,CAAC;IACF,CAAC;IAED;;;;OAIG;IACH,qBAA4B,KAAwB;QAEnD,EAAE,CAAA,CAAC,yBAAyB,CAAC,KAAK,CAAC,CAAC,CACpC,CAAC;YACA,IAAM,CAAC,GAAU,KAAK,CAAC,cAAc,EAAE,CAAC;YACxC,EAAE,CAAA,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,IAAE,CAAC,CAAC;gBACrC,MAAM,6CAA6C,CAAC;YACrD,MAAM,CAAC,CAAC,CAAC;QACV,CAAC;QACD,IAAI,CACJ,CAAC;YACA,MAAM,CAAC,kBAAkB,CAAC,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;QACtD,CAAC;IACF,CAAC;;IAED;;;;OAIG;IACH,mCAA0C,QAAY;QAErD,MAAM,CAAC,YAAI,CAAC,eAAe,CAA2B,QAAQ,EAAE,gBAAgB,EAAE,YAAI,CAAC,QAAQ,CAAC,CAAC;IAClG,CAAC;;IAED;;;;;;OAMG;IACH,eACC,KAAY,EACZ,YAAgD,EAChD,WAA0B,EAC1B,YAA2B;QAD3B,4BAAA,EAAA,kBAA0B;QAC1B,6BAAA,EAAA,mBAA2B;QAE3B,EAAE,CAAA,CAAC,KAAK,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC,CAAC,CACnD,CAAC;YACA,IAAM,OAAO,GAAG,KAAK,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YAC7C,GAAG,CAAA,CAAc,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO;gBAApB,IAAI,KAAK,gBAAA;gBAEZ;;;mBAGG;gBACH,IAAM,EAAE,GAAG,KAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC;gBAC9C,EAAE,CAAA,CAAC,EAAE,IAAG,CAAC,CAAC,CAAC,CACX,CAAC;oBACA,IAAI,GAAG,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;oBACjC,IAAI,KAAK,GAAQ,KAAK,CAAC,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;oBACzC,EAAE,CAAA,CAAC,YAAY,CAAC;wBAAC,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;oBACnD,EAAE,CAAA,CAAC,WAAW,CAAC;wBAAC,KAAK,GAAG,SAAS,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;oBACrD,YAAY,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;gBAC1B,CAAC;aACD;QACF,CAAC;IACF,CAAC;;IAED;;;;;;OAMG;IACH,oBACC,KAAY,EACZ,WAA0B,EAC1B,YAA2B;QAD3B,4BAAA,EAAA,kBAA0B;QAC1B,6BAAA,EAAA,mBAA2B;QAE3B,IAAM,MAAM,GAA+B,EAAE,CAAC;QAC9C,KAAK,CAAC,KAAK,EACV,UAAC,GAAG,EAAE,KAAK;YAEV,EAAE,CAAA,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CACrB,CAAC;gBACA,IAAI,IAAI,GAAO,MAAM,CAAC,GAAG,CAAC,CAAC;gBAC3B,EAAE,CAAA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,YAAU,CAAC,KAAK,CAAC,CAAC,CAAC;oBAC7B,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;gBAC7B,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAClB,CAAC;YACD,IAAI;gBACH,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACtB,CAAC,EACD,WAAW,EACX,YAAY,CAAC,CAAC;QACf,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;;IAED;;;;;;OAMG;IACH,sBACC,KAAY,EACZ,WAA0B,EAC1B,YAA2B;QAD3B,4BAAA,EAAA,kBAA0B;QAC1B,6BAAA,EAAA,mBAA2B;QAE3B,IAAM,MAAM,GAAoC,EAAE,CAAC;QACnD,KAAK,CAAC,KAAK,EACV,UAAC,GAAG,EAAE,KAAK,IAAK,MAAM,CAAC,IAAI,CAAC,EAAC,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,KAAK,EAAC,CAAC,CAAC,CAAA,CAAC,EACvD,WAAW,EACX,YAAY,CACZ,CAAC;QACF,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;;;;;;;;;;;;;;;;;;;YAvLD;;;eAGG;YAGF,KAAK,GAAiB,EAAE,EACxB,eAAe,GAAO,GAAG,EACzB,eAAe,GAAO,GAAG,EACzB,mBAAmB,GAAG,GAAG,EACzB,gBAAgB,GAAM,gBAAgB,CAAC;YAgLxC,WAAc,SAAS;gBAET,eAAK,GAAU,eAAe,CAAC;gBAC/B,eAAK,GAAU,eAAe,CAAC;gBAC/B,kBAAQ,GAAU,mBAAmB,CAAC;YACpD,CAAC,EALa,SAAS,KAAT,SAAS,QAKtB;;YACD,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAEzB,CAAC","file":"QueryParams.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport * as Serialize from \"../Serialization/Utility\";\r\nimport {UriComponent} from \"./UriComponent\";\r\nimport {QueryParam} from \"./QueryParam\";\r\nimport {Type} from \"../Types\";\r\nimport {extractKeyValue} from \"../KeyValueExtract\";\r\nimport {forEach, isEnumerableOrArrayLike} from \"../Collections/Enumeration/Enumerator\";\r\nimport {IMap} from \"../../IMap\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {IStringKeyValuePair} from \"../KeyValuePair\";\r\nimport {IEnumerableOrArray} from \"../Collections/IEnumerableOrArray\";\r\n\r\n/*\r\n * This module is provided as a lighter weight utility for acquiring query params.\r\n * If more detailed operations are necessary, consider importing QueryBuilder.\r\n */\r\n\r\nconst\r\n\tEMPTY               = \"\",\r\n\tQUERY_SEPARATOR     = \"?\",\r\n\tENTRY_SEPARATOR     = \"&\",\r\n\tKEY_VALUE_SEPARATOR = \"=\",\r\n\tTO_URI_COMPONENT    = \"toUriComponent\";\r\n\r\n\r\n/**\r\n * Returns the encoded URI string\r\n * @param values\r\n * @param prefixIfNotEmpty\r\n * @returns {string}\r\n */\r\nexport function encode(\r\n\tvalues:UriComponent.Map | QueryParam.EnumerableOrArray,\r\n\tprefixIfNotEmpty?:boolean):string\r\n{\r\n\tif(!values) return EMPTY;\r\n\tconst entries:string[] = [];\r\n\r\n\tif(isEnumerableOrArrayLike(values))\r\n\t{\r\n\t\tforEach(values, entry=>\r\n\t\t\textractKeyValue(entry,\r\n\t\t\t\t(key, value)=> appendKeyValue(entries, key, value))\r\n\t\t);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tObject.keys(values).forEach(\r\n\t\t\tkey=> appendKeyValue(entries, key, values[key])\r\n\t\t);\r\n\t}\r\n\r\n\treturn (entries.length && prefixIfNotEmpty ? QUERY_SEPARATOR : EMPTY)\r\n\t\t+ entries.join(ENTRY_SEPARATOR);\r\n}\r\n\r\nfunction appendKeyValueSingle(\r\n\tentries:string[],\r\n\tkey:string,\r\n\tvalue:UriComponent.Value):void\r\n{\r\n\tentries.push(key + KEY_VALUE_SEPARATOR + encodeValue(value));\r\n}\r\n\r\n// According to spec, if there is an array of values with the same key, then each value is replicated with that key.\r\nfunction appendKeyValue(\r\n\tentries:string[],\r\n\tkey:string,\r\n\tvalue:UriComponent.Value|IEnumerableOrArray<UriComponent.Value>):void\r\n{\r\n\tif(isEnumerableOrArrayLike(value))\r\n\t{\r\n\t\tforEach(value, v=> appendKeyValueSingle(entries, key, v));\r\n\t}\r\n\telse\r\n\t{\r\n\t\tappendKeyValueSingle(entries, key, value)\r\n\t}\r\n}\r\n\r\n/**\r\n * Converts any primitive, serializable or uri-component object to an encoded string.\r\n * @param value\r\n * @returns {string}\r\n */\r\nexport function encodeValue(value:UriComponent.Value):string\r\n{\r\n\tif(isUriComponentFormattable(value))\r\n\t{\r\n\t\tconst v:string = value.toUriComponent();\r\n\t\tif(v && v.indexOf(ENTRY_SEPARATOR)!=1)\r\n\t\t\tthrow '.toUriComponent() did not encode the value.';\r\n\t\treturn v;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn encodeURIComponent(Serialize.toString(value));\r\n\t}\r\n}\r\n\r\n/**\r\n * A shortcut for identifying an UriComponent.Formattable object.\r\n * @param instance\r\n * @returns {boolean}\r\n */\r\nexport function isUriComponentFormattable(instance:any):instance is UriComponent.Formattable\r\n{\r\n\treturn Type.hasMemberOfType<UriComponent.Formattable>(instance, TO_URI_COMPONENT, Type.FUNCTION);\r\n}\r\n\r\n/**\r\n * Parses a string for valid query param entries and pipes them through a handler.\r\n * @param query\r\n * @param entryHandler\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n */\r\nexport function parse(\r\n\tquery:string,\r\n\tentryHandler:(key:string, value:Primitive)=>void,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):void\r\n{\r\n\tif(query && (query = query.replace(/^\\s*\\?+/, '')))\r\n\t{\r\n\t\tconst entries = query.split(ENTRY_SEPARATOR);\r\n\t\tfor(let entry of entries)\r\n\t\t{\r\n\t\t\t/*\r\n\t\t\t * Since it is technically possible to have multiple '=' we need to identify the first one.\r\n\t\t\t * And if there is no '=' then the entry is ignored.\r\n\t\t\t */\r\n\t\t\tconst si = entry.indexOf(KEY_VALUE_SEPARATOR);\r\n\t\t\tif(si!= -1)\r\n\t\t\t{\r\n\t\t\t\tlet key = entry.substring(0, si);\r\n\t\t\t\tlet value = <any>entry.substring(si + 1);\r\n\t\t\t\tif(decodeValues) value = decodeURIComponent(value);\r\n\t\t\t\tif(deserialize) value = Serialize.toPrimitive(value);\r\n\t\t\t\tentryHandler(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value map of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IMap<Primitive>}\r\n */\r\nexport function parseToMap(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IMap<Primitive|Primitive[]>\r\n{\r\n\tconst result:IMap<Primitive|Primitive[]> = {};\r\n\tparse(query,\r\n\t\t(key, value)=>\r\n\t\t{\r\n\t\t\tif((key) in (result))\r\n\t\t\t{\r\n\t\t\t\tlet prev:any = result[key];\r\n\t\t\t\tif(!((prev)instanceof(Array)))\r\n\t\t\t\t\tresult[key] = prev = [prev];\r\n\t\t\t\tprev.push(value);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tresult[key] = value;\r\n\t\t},\r\n\t\tdeserialize,\r\n\t\tdecodeValues);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value pair array of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IKeyValuePair<string, Primitive>[]}\r\n */\r\nexport function parseToArray(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IStringKeyValuePair<Primitive>[]\r\n{\r\n\tconst result:IStringKeyValuePair<Primitive>[] = [];\r\n\tparse(query,\r\n\t\t(key, value)=> {result.push({key: key, value: value});},\r\n\t\tdeserialize,\r\n\t\tdecodeValues\r\n\t);\r\n\treturn result;\r\n}\r\n\r\n\r\nexport module Separator\r\n{\r\n\texport const Query:string = QUERY_SEPARATOR;\r\n\texport const Entry:string = ENTRY_SEPARATOR;\r\n\texport const KeyValue:string = KEY_VALUE_SEPARATOR;\r\n}\r\nObject.freeze(Separator);\r\n\r\n"]}