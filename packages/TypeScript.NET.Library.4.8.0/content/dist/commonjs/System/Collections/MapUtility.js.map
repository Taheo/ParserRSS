{"version":3,"sources":["System/Collections/MapUtility.ts"],"names":[],"mappings":";;AAMA;;;;;GAKG;AACH,eACC,MAAQ,EACR,MAAQ;IAER,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;IAChC,GAAG,CAAA,CAAC,IAAM,GAAG,IAAI,MAAM,CAAC,CACxB,CAAC;QACA,EAAE,CAAA,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC9B,CAAC;YACA,MAAM,CAAC,GAAG,CAAC,GAAS,MAAO,CAAC,GAAG,CAAC,CAAC;QAClC,CAAC;IACF,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;AAbD,sBAaC;AAED;;;;;GAKG;AACH,gBACC,MAAQ,EACR,QAAU;IAEV,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;IAChC,GAAG,CAAA,CAAC,IAAM,GAAG,IAAI,QAAQ,CAAC,CAC1B,CAAC;QACA,EAAE,CAAA,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC/D,CAAC;YACA,MAAM,CAAC,GAAG,CAAC,GAAS,QAAS,CAAC,GAAG,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;AAbD,wBAaC;AAED;;;;GAIG;AACH,cAA0C,MAAQ;IAEjD,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;AAC1B,CAAC;AAHD,oBAGC;AAGD;;;;;GAKG;AACH,eACC,CAAG,EACH,CAAG;IAEH,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC1B,CAAC;AALD,sBAKC;AAED;;;;GAIG;AACH,cAAgD,MAAgB,EAAE,MAAc;IAE/E,GAAG,CAAA,CAAC,IAAM,GAAG,IAAI,MAAM,CAAC,CACxB,CAAC;QACA,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC/B,CAAC;YACA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;QACpB,CAAC;IACF,CAAC;IACD,qBAAqB;AACtB,CAAC;AAVD,oBAUC","file":"MapUtility.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {IMap} from \"../../IMap\";\r\n\r\n/**\r\n * Takes a target object and applies all source values to it.\r\n * @param target\r\n * @param source\r\n * @returns {any}\r\n */\r\nexport function apply<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tsource:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in source)\r\n\t{\r\n\t\tif(source.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>source)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes a target object and ensures values exist.\r\n * @param target\r\n * @param defaults\r\n * @returns {any}\r\n */\r\nexport function ensure<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tdefaults:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in defaults)\r\n\t{\r\n\t\tif(defaults.hasOwnProperty(key) && !result.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>defaults)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Make a copy of the source object.\r\n * @param source\r\n * @returns {Object}\r\n */\r\nexport function copy<T extends IMap<any>>(source:T):T\r\n{\r\n\treturn apply({}, source);\r\n}\r\n\r\n\r\n/**\r\n * Takes two objects and creates another with the values of both.\r\n * B overwrites A.\r\n * @param a\r\n * @param b\r\n */\r\nexport function merge<A extends IMap<any>, B extends IMap<any>>(\r\n\ta:A,\r\n\tb:B):A & B\r\n{\r\n\treturn apply(copy(a), b);\r\n}\r\n\r\n/**\r\n * Removes any keys that don't exist on the keyMap.\r\n * @param target\r\n * @param keyMap\r\n */\r\nexport function trim<TResult extends IMap<any>>(target:IMap<any>, keyMap:TResult):void //Partial<TResult>\r\n{\r\n\tfor(const key in target)\r\n\t{\r\n\t\tif(!keyMap.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tdelete target[key];\r\n\t\t}\r\n\t}\r\n\t//return <any>target;\r\n}"]}