{"version":3,"sources":["System/Collections/Array/Dispatch.js","System/Collections/Array/Dispatch.ts"],"names":["define","require","exports","Types_1","copy_1","dispatch","listeners","payload","trap","unsafe","copy","Object","defineProperty","value","VOID0","length","i","len","fn","ex","Type","isFunction","mapped","result"],"mappings":"AAAAA,QAAQ,UAAW,UAAW,cAAe,UAAW,SAAUC,EAASC,EAASC,EAASC,GACzF,YCsBJ,SAAAC,GACCC,EACAC,EAAWC,GAEXH,EAASI,OAAOL,EAAAM,KAAKJ,GAAYC,EAASC,GDzBvCG,OAAOC,eAAeV,EAAS,cAAgBW,OAAO,GCM1D,IAAMC,GAAkB,MAexBZ,GAAAG,SAAAA,EAOA,SAAcA,GAuBb,QAAAI,GACCH,EACAC,EAAWC,GAEX,GAAGF,GAAaA,EAAUS,OAEzB,IAAI,GAAIC,GAAI,EAAGC,EAAMX,EAAUS,OAAQC,EAAEC,EAAKD,IAC9C,CACC,GAAIE,GAAcZ,EAAUU,EAC5B,IAAIE,EACJ,IAECA,EAAGX,GAEJ,MAAMY,GAEL,IAAIX,EACH,KAAMW,EACChB,GAAAiB,KAAKC,WAAWb,IACvBA,EAAKW,EAAIH,KAed,QAAAM,GACChB,EACAC,EAAWC,GAGX,IAAIF,EAAW,MAAYA,EAE3B,IAAMiB,GAAenB,EAAAM,KAAKJ,EAC1B,IAAGA,EAAUS,OAGZ,IAAI,GAAIC,GAAI,EAAGC,EAAMM,EAAOR,OAAQC,EAAEC,EAAKD,IAC3C,CACC,GAAIE,GAAcK,EAAOP,EACzB,KAECO,EAAOP,GAAKE,EACTA,EAAGX,GACHO,EAEJ,MAAMK,GAGL,GADAI,EAAOP,GAAKF,GACRN,EACH,KAAMW,EACChB,GAAAiB,KAAKC,WAAWb,IACvBA,EAAKW,EAAIH,IAKb,MAAOO,GAjEQlB,EAAAI,OAAMA,EAkCNJ,EAAAiB,OAAMA,GAzDTjB,EAAAH,EAAAG,WAAAH,EAAAG,cA8FdH,EAAAA,WAAeG","file":"Dispatch.js","sourcesContent":["define([\"require\", \"exports\", \"../../Types\", \"./copy\"], function (require, exports, Types_1, copy_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var VOID0 = void 0;\n    /**\n     * Simply takes a payload and passes it to all the listeners.\n     * Makes a arrayCopy of the listeners before calling dispatchUnsafe.\n     *\n     * @param listeners\n     * @param payload\n     * @param trap\n     */\n    function dispatch(listeners, payload, trap) {\n        dispatch.unsafe(copy_1.copy(listeners), payload, trap);\n    }\n    exports.dispatch = dispatch;\n    (function (dispatch) {\n        /**\n         * Simply takes a payload and passes it to all the listeners.\n         *\n         * While dispatching:\n         * * This is an unsafe method if by chance any of the listeners modify the array.\n         * * It cannot prevent changes to the payload.\n         *\n         * Improving safety:\n         * * Only use a local array that isn't exposed to the listeners.\n         * * Use the dispatch method instead as it makes a arrayCopy of the listeners array.\n         * * Freeze the listeners array so it can't be modified.\n         * * Freeze the payload.\n         *\n         * Specifying trap will catch any errors and pass them along if trap is a function.\n         * A payload is used instead of arguments for easy typing.\n         *\n         *\n         * @param listeners\n         * @param payload\n         * @param trap\n         */\n        function unsafe(listeners, payload, trap) {\n            if (listeners && listeners.length) {\n                for (var i = 0, len = listeners.length; i < len; i++) {\n                    var fn = listeners[i];\n                    if (!fn)\n                        continue; // Ignore null refs.\n                    try {\n                        fn(payload);\n                    }\n                    catch (ex) {\n                        if (!trap)\n                            throw ex;\n                        else if (Types_1.Type.isFunction(trap))\n                            trap(ex, i);\n                    }\n                }\n            }\n        }\n        dispatch.unsafe = unsafe;\n        /**\n         * Simply takes a payload and passes it to all the listeners.\n         * Returns the results in an array that matches the indexes of the listeners.\n         *\n         * @param listeners\n         * @param payload\n         * @param trap\n         * @returns {any}\n         */\n        function mapped(listeners, payload, trap) {\n            if (!listeners)\n                return listeners;\n            // Reuse the arrayCopy as the array result.\n            var result = copy_1.copy(listeners);\n            if (listeners.length) {\n                for (var i = 0, len = result.length; i < len; i++) {\n                    var fn = result[i];\n                    try {\n                        result[i] = fn // Ignore null refs.\n                            ? fn(payload)\n                            : VOID0;\n                    }\n                    catch (ex) {\n                        result[i] = VOID0;\n                        if (!trap)\n                            throw ex;\n                        else if (Types_1.Type.isFunction(trap))\n                            trap(ex, i);\n                    }\n                }\n            }\n            return result;\n        }\n        dispatch.mapped = mapped;\n    })(dispatch = exports.dispatch || (exports.dispatch = {}));\n    exports.default = dispatch;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {Type} from \"../../Types\";\r\nimport {copy} from \"./copy\";\r\nimport {Selector} from \"../../FunctionTypes\";\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\nexport interface DispatchErrorHandler\r\n{\r\n\t(ex:any, index:number):void\r\n}\r\n\r\n/**\r\n * Simply takes a payload and passes it to all the listeners.\r\n * Makes a arrayCopy of the listeners before calling dispatchUnsafe.\r\n *\r\n * @param listeners\r\n * @param payload\r\n * @param trap\r\n */\r\nexport function dispatch<T>(\r\n\tlisteners:ArrayLike<Selector<T,any>>,\r\n\tpayload:T, trap?:boolean|DispatchErrorHandler):void\r\n{\r\n\tdispatch.unsafe(copy(listeners), payload, trap);\r\n}\r\n\r\nexport module dispatch {\r\n\r\n\t/**\r\n\t * Simply takes a payload and passes it to all the listeners.\r\n\t *\r\n\t * While dispatching:\r\n\t * * This is an unsafe method if by chance any of the listeners modify the array.\r\n\t * * It cannot prevent changes to the payload.\r\n\t *\r\n\t * Improving safety:\r\n\t * * Only use a local array that isn't exposed to the listeners.\r\n\t * * Use the dispatch method instead as it makes a arrayCopy of the listeners array.\r\n\t * * Freeze the listeners array so it can't be modified.\r\n\t * * Freeze the payload.\r\n\t *\r\n\t * Specifying trap will catch any errors and pass them along if trap is a function.\r\n\t * A payload is used instead of arguments for easy typing.\r\n\t *\r\n\t *\r\n\t * @param listeners\r\n\t * @param payload\r\n\t * @param trap\r\n\t */\r\n\texport function unsafe<T>(\r\n\t\tlisteners:ArrayLike<Selector<T,any>>,\r\n\t\tpayload:T, trap?:boolean|DispatchErrorHandler):void\r\n\t{\r\n\t\tif(listeners && listeners.length)\r\n\t\t{\r\n\t\t\tfor(let i = 0, len = listeners.length; i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet fn:Function = listeners[i];\r\n\t\t\t\tif(!fn) continue; // Ignore null refs.\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tfn(payload);\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!trap)\r\n\t\t\t\t\t\tthrow ex;\r\n\t\t\t\t\telse if(Type.isFunction(trap))\r\n\t\t\t\t\t\ttrap(ex, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Simply takes a payload and passes it to all the listeners.\r\n\t * Returns the results in an array that matches the indexes of the listeners.\r\n\t *\r\n\t * @param listeners\r\n\t * @param payload\r\n\t * @param trap\r\n\t * @returns {any}\r\n\t */\r\n\texport function mapped<T,TResult>(\r\n\t\tlisteners:ArrayLike<Selector<T,TResult>>,\r\n\t\tpayload:T, trap?:boolean|DispatchErrorHandler):TResult[]\r\n\t{\r\n\r\n\t\tif(!listeners) return <any>listeners;\r\n\t\t// Reuse the arrayCopy as the array result.\r\n\t\tconst result:any[] = copy(listeners);\r\n\t\tif(listeners.length)\r\n\t\t{\r\n\r\n\t\t\tfor(let i = 0, len = result.length; i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet fn:Function = result[i];\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = fn // Ignore null refs.\r\n\t\t\t\t\t\t? fn(payload)\r\n\t\t\t\t\t\t: VOID0;\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = VOID0;\r\n\t\t\t\t\tif(!trap)\r\n\t\t\t\t\t\tthrow ex;\r\n\t\t\t\t\telse if(Type.isFunction(trap))\r\n\t\t\t\t\t\ttrap(ex, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default dispatch;"]}