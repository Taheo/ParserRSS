{"version":3,"sources":["System/Collections/Array/Sorting/mergeSort.js","System/Collections/Array/Sorting/mergeSort.ts"],"names":["define","require","exports","ArgumentNullException_1","Utility_1","mergeSort","target","ArgumentNullException","len","length","sort","initialize","start","end","temp","middle","Math","floor","i_1","k","i","j","Object","defineProperty","value"],"mappings":"AAAAA,QAAQ,UAAW,UAAW,4CAA6C,cAAe,SAAUC,EAASC,EAASC,EAAyBC,GAC3I,YCgBJ,SAAAC,GAAoFC,GAEnF,IAAIA,EAAQ,KAAM,IAAIH,GAAAI,sBAAsB,SAC5C,IAAMC,GAAMF,EAAOG,MACnB,OAAOD,GAAI,EAAIF,EAASI,EAAKJ,EAAQ,EAAGE,EAAKJ,EAAAO,WAAcH,IAG5D,QAAAE,GACCJ,EACAM,EACAC,EACAC,GAEA,GAAGD,EAAMD,EAAM,EACf,CAEC,GAAMG,GAASC,KAAKC,OAAOL,EAAQC,GAAK,EACxCH,GAAKJ,EAAQM,EAAOG,EAAQD,GAC5BJ,EAAKJ,EAAQS,EAAQF,EAAKC,EAG1B,KAAI,GAAII,GAAI,EAAGV,EAAMF,EAAOG,OAAQS,EAAEV,EAAKU,IAE1CJ,EAAKI,GAAKZ,EAAOY,EAOlB,KAHA,GAAIC,GAAIP,EAAOQ,EAAIR,EAAOS,EAAIN,EAGxBK,EAAEL,GAAUM,EAAER,GAEnBP,EAAOa,KACJL,EAAKM,GAAGN,EAAKO,GACbP,EAAKO,KACLP,EAAKM,IAIT,MAAMA,EAAEL,GAEPT,EAAOa,KAAOL,EAAKM,KAKrB,MAAOd,GD7DJgB,OAAOC,eAAerB,EAAS,cAAgBsB,OAAO,ICe1DtB,EAAAG,UAAAA","file":"mergeSort.js","sourcesContent":["define([\"require\", \"exports\", \"../../../Exceptions/ArgumentNullException\", \"../Utility\"], function (require, exports, ArgumentNullException_1, Utility_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Merge internalSort O(n log (n))\n     * Warning: Uses recursion.\n     * @param target\n     * @returns {number[]}\n     */\n    function mergeSort(target) {\n        if (!target)\n            throw new ArgumentNullException_1.ArgumentNullException(\"target\");\n        var len = target.length;\n        return len < 2 ? target : sort(target, 0, len, Utility_1.initialize(len));\n    }\n    exports.mergeSort = mergeSort;\n    function sort(target, start, end, temp) {\n        if (end - start > 1) {\n            // Step 1: Sort the left and right parts.\n            var middle = Math.floor((start + end) / 2);\n            sort(target, start, middle, temp);\n            sort(target, middle, end, temp);\n            // Step 2: Copy the original array\n            for (var i_1 = 0, len = target.length; i_1 < len; i_1++) {\n                temp[i_1] = target[i_1];\n            }\n            // Step 3: Create variables to traverse\n            var k = start, i = start, j = middle;\n            // Step 4: Merge: Move from the temp to target integers in order\n            while (i < middle && j < end) {\n                target[k++]\n                    = temp[i] > temp[j]\n                        ? temp[j++]\n                        : temp[i++];\n            }\n            // Step 5: Finalize merging in case right side of the array is bigger.\n            while (i < middle) {\n                target[k++] = temp[i++];\n            }\n        }\n        return target;\n    }\n});\n","/*!\r\n * @author Sebastian Belmar / https://github.com/sebabelmar/\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * https://en.wikipedia.org/wiki/Merge_sort\r\n */\r\nimport {Primitive} from \"../../../Primitive\";\r\nimport {ArgumentNullException} from \"../../../Exceptions/ArgumentNullException\";\r\nimport {initialize} from \"../Utility\";\r\nimport {ArrayLikeWritable} from \"../ArrayLikeWritable\";\r\n\r\n/**\r\n * Merge internalSort O(n log (n))\r\n * Warning: Uses recursion.\r\n * @param target\r\n * @returns {number[]}\r\n */\r\nexport function mergeSort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target:TArray):TArray\r\n{\r\n\tif(!target) throw new ArgumentNullException(\"target\");\r\n\tconst len = target.length;\r\n\treturn len<2 ? target : sort(target, 0, len, initialize<T>(len));\r\n}\r\n\r\nfunction sort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(\r\n\ttarget:TArray,\r\n\tstart:number,\r\n\tend:number,\r\n\ttemp:ArrayLikeWritable<T>):TArray\r\n{\r\n\tif(end - start>1)\r\n\t{\r\n\t\t// Step 1: Sort the left and right parts.\r\n\t\tconst middle = Math.floor((start + end)/2);\r\n\t\tsort(target, start, middle, temp);\r\n\t\tsort(target, middle, end, temp);\r\n\r\n\t\t// Step 2: Copy the original array\r\n\t\tfor(let i = 0, len = target.length; i<len; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = target[i];\r\n\t\t}\r\n\r\n\t\t// Step 3: Create variables to traverse\r\n\t\tlet k = start, i = start, j = middle;\r\n\r\n\t\t// Step 4: Merge: Move from the temp to target integers in order\r\n\t\twhile(i<middle && j<end)\r\n\t\t{\r\n\t\t\ttarget[k++]\r\n\t\t\t\t= temp[i]>temp[j]\r\n\t\t\t\t? temp[j++]\r\n\t\t\t\t: temp[i++];\r\n\t\t}\r\n\r\n\t\t// Step 5: Finalize merging in case right side of the array is bigger.\r\n\t\twhile(i<middle)\r\n\t\t{\r\n\t\t\ttarget[k++] = temp[i++];\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn target\r\n}\r\n"]}