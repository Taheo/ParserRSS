{"version":3,"sources":["System/Collections/HashSet.js","System/Collections/HashSet.ts"],"names":["define","require","exports","Types_1","SetBase_1","ArgumentNullException_1","extends_1","wipe","map","depth","_i","_a","Object","keys","length","key","v","defineProperty","value","__extends","VOID0","HashSet","_super","source","keyGenerator","_this","call","this","Type","isFunction","_keyGenerator","ArgumentNullException","_importEntries","prototype","newUsing","_addInternal","item","_","type","r","_registry","t","node","_getSet","addNode","_clearInternal","_onDispose","_getNode","_removeInternal","max","Infinity","s","_set","removeNode","SetBase"],"mappings":"AAAAA,QAAQ,UAAW,UAAW,WAAY,YAAa,sCAAuC,iBAAkB,SAAUC,EAASC,EAASC,EAASC,EAAWC,EAAyBC,GACrL,YCgHJ,SAAAC,GAAcC,EAAeC,GAE5B,GAF4B,SAAAA,IAAAA,EAAA,GAEzBD,GAAOC,EAET,IAAe,GAAAC,GAAA,EAAAC,EAAAC,OAAOC,KAAKL,GAAZE,EAAAC,EAAAG,OAAAJ,IAAgB,CAA3B,GAAIK,GAAGJ,EAAAD,GAENM,EAAIR,EAAIO,SACLP,GAAIO,GACXR,EAAKS,EAAGP,EAAQ,IDvHfG,OAAOK,eAAef,EAAS,cAAgBgB,OAAO,GCW1D,IAAMC,GAAYb,EAAAA,WAGZc,EAAkB,OAExBC,EAAA,SAAAC,GAOC,QAAAD,GAAYE,EAAyEC,GAArF,GAAAC,GAECH,EAAAI,KAAAC,OAAOA,IACP,IAAGxB,EAAAyB,KAAKC,WAAWN,GAClBE,EAAKK,cAAgBP,MACf,CACN,IAAIC,EACH,KAAM,IAAInB,GAAA0B,sBAAsB,eACjCN,GAAKK,cAAgBN,EACrBC,EAAKO,eAAeT,GDfX,MAAOE,GC4FnB,MA5FQN,GAAAE,EAAAC,GAoBGD,EAAAY,UAAAC,SAAV,SAAmBX,GAElB,MAAO,IAAIF,GAAWE,EAAOI,KAAKG,gBAKzBT,EAAAY,UAAAE,aAAV,SAAuBC,GAEtB,GAAMC,GAAIV,KACJW,QAAcF,GAChBG,EAAIF,EAAEG,UAAWC,EAAIF,GAAKA,EAAED,GAC1BvB,EAAMsB,EAAEP,cAAcM,EAC5B,KAAIK,GAAKA,EAAE1B,KAAOK,EAClB,CACKmB,IAEHF,EAAEG,UAAYD,MAEXE,IAEHF,EAAED,GAAQG,KAGX,IAAMC,IAAgCxB,MAAOkB,EAG7C,OAFAC,GAAEM,UAAUC,QAAQF,GACpBD,EAAE1B,GAAO2B,GACF,EAER,OAAO,GAGErB,EAAAY,UAAAY,eAAV,WAGC,MADAtC,GAAKoB,KAAKa,UAAW,GACdlB,EAAAW,UAAMY,eAAcnB,KAAAC,OAGlBN,EAAAY,UAAAa,WAAV,WAECxB,EAAAW,UAAMa,WAAUpB,KAAAC,MAChBA,KAAKa,UAAiB,KAChBb,KAAMG,cAAgBV,GAGnBC,EAAAY,UAAAc,SAAV,SAAmBX,GAElB,GAAMG,GAAIZ,KAAKa,UAAWC,EAAIF,GAAKA,QAASH,GAC5C,OAAOK,IAAKA,EAAEd,KAAKG,cAAcM,KAGxBf,EAAAY,UAAAe,gBAAV,SAA0BZ,EAAQa,GAEjC,GAFiC,SAAAA,IAAAA,EAAAC,EAAAA,GAExB,IAAND,EAAS,MAAO,EAEnB,IAAMV,GAAOZ,KAAKa,UACZC,EAAOF,GAAKA,QAASH,IACrBM,EAAOD,GAAKA,EAAOL,EAEzB,IAAGM,EACH,OACQD,GAAOL,EACd,IAAMe,GAAIxB,KAAKyB,IACf,IAAGD,GAAKA,EAAEE,WAAWX,GAEpB,MAAO,GAIT,MAAO,IAGTrB,GA5FQjB,EAAAkD,QADKpD,GAAAmB,QAAAA,EA4GbnB,EAAAA,WAAemB","file":"HashSet.js","sourcesContent":["define([\"require\", \"exports\", \"../Types\", \"./SetBase\", \"../Exceptions/ArgumentNullException\", \"../../extends\"], function (require, exports, Types_1, SetBase_1, ArgumentNullException_1, extends_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    var HashSet = (function (_super) {\n        __extends(HashSet, _super);\n        function HashSet(source, keyGenerator) {\n            var _this = _super.call(this) || this;\n            if (Types_1.Type.isFunction(source)) {\n                _this._keyGenerator = source;\n            }\n            else {\n                if (!keyGenerator)\n                    throw new ArgumentNullException_1.ArgumentNullException(\"keyGenerator\");\n                _this._keyGenerator = keyGenerator;\n                _this._importEntries(source);\n            }\n            return _this;\n        }\n        HashSet.prototype.newUsing = function (source) {\n            return new HashSet(source, this._keyGenerator);\n        };\n        HashSet.prototype._addInternal = function (item) {\n            var _ = this;\n            var type = typeof item;\n            var r = _._registry, t = r && r[type];\n            var key = _._keyGenerator(item);\n            if (!t || t[key] === VOID0) {\n                if (!r) {\n                    //noinspection JSUnusedAssignment\n                    _._registry = r = {};\n                }\n                if (!t) {\n                    //noinspection JSUnusedAssignment\n                    r[type] = t = {};\n                }\n                var node = { value: item };\n                _._getSet().addNode(node);\n                t[key] = node;\n                return true;\n            }\n            return false;\n        };\n        HashSet.prototype._clearInternal = function () {\n            wipe(this._registry, 2);\n            return _super.prototype._clearInternal.call(this);\n        };\n        HashSet.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._registry = null;\n            this._keyGenerator = VOID0;\n        };\n        HashSet.prototype._getNode = function (item) {\n            var r = this._registry, t = r && r[typeof item];\n            return t && t[this._keyGenerator(item)];\n        };\n        HashSet.prototype._removeInternal = function (item, max) {\n            if (max === void 0) { max = Infinity; }\n            if (max === 0)\n                return 0;\n            var r = this._registry, t = r && r[typeof item], node = t && t[item];\n            if (node) {\n                delete t[item];\n                var s = this._set;\n                if (s && s.removeNode(node)) {\n                    return 1;\n                }\n            }\n            return 0;\n        };\n        return HashSet;\n    }(SetBase_1.SetBase));\n    exports.HashSet = HashSet;\n    function wipe(map, depth) {\n        if (depth === void 0) { depth = 1; }\n        if (map && depth) {\n            for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {\n                var key = _a[_i];\n                var v = map[key];\n                delete map[key];\n                wipe(v, depth - 1);\n            }\n        }\n    }\n    exports.default = HashSet;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {Type} from \"../Types\";\r\nimport {SetBase} from \"./SetBase\";\r\nimport {IMap} from \"../../IMap\";\r\nimport {ILinkedNodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerableOrArray} from \"./IEnumerableOrArray\";\r\nimport {Selector} from \"../FunctionTypes\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\nexport class HashSet<T>\r\nextends SetBase<T>\r\n{\r\n\tprivate readonly _keyGenerator:Selector<T,string|number|symbol>;\r\n\r\n\tconstructor(keyGenerator:Selector<T,string|number|symbol>)\r\n\tconstructor(source:IEnumerableOrArray<T>|undefined, keyGenerator:Selector<T,string|number|symbol>)\r\n\tconstructor(source:IEnumerableOrArray<T>|Selector<T,string|number|symbol>|undefined, keyGenerator?:Selector<T,string|number|symbol>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(Type.isFunction(source)) {\r\n\t\t\tthis._keyGenerator = source;\r\n\t\t} else {\r\n\t\t\tif(!keyGenerator)\r\n\t\t\t\tthrow new ArgumentNullException(\"keyGenerator\");\r\n\t\t\tthis._keyGenerator = keyGenerator;\r\n\t\t\tthis._importEntries(source);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tprotected newUsing(source?:IEnumerableOrArray<T>):HashSet<T>\r\n\t{\r\n\t\treturn new HashSet<T>(source,this._keyGenerator);\r\n\t}\r\n\r\n\tprivate _registry:IMap<IMap<ILinkedNodeWithValue<T>>>;\r\n\r\n\tprotected _addInternal(item:T):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst type = typeof item;\r\n\t\tlet r = _._registry, t = r && r[type];\r\n\t\tconst key = _._keyGenerator(item);\r\n\t\tif(!t || t[key]===VOID0)\r\n\t\t{\r\n\t\t\tif(!r) {\r\n\t\t\t\t//noinspection JSUnusedAssignment\r\n\t\t\t\t_._registry = r = {};\r\n\t\t\t}\r\n\t\t\tif(!t) {\r\n\t\t\t\t//noinspection JSUnusedAssignment\r\n\t\t\t\tr[type] = t = {};\r\n\t\t\t}\r\n\r\n\t\t\tconst node:ILinkedNodeWithValue<T> = {value: item};\r\n\t\t\t_._getSet().addNode(node);\r\n\t\t\tt[key] = node;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\twipe(this._registry, 2);\r\n\t\treturn super._clearInternal();\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._registry = <any>null;\r\n\t\t(<any>this)._keyGenerator = VOID0;\r\n\t}\r\n\r\n\tprotected _getNode(item:T):ILinkedNodeWithValue<T>|undefined\r\n\t{\r\n\t\tconst r = this._registry, t = r && r[typeof item];\r\n\t\treturn t && t[this._keyGenerator(item)];\r\n\t}\r\n\r\n\tprotected _removeInternal(item:T, max:number = Infinity):number\r\n\t{\r\n\t\tif(max===0) return 0;\r\n\r\n\t\tconst r    = this._registry,\r\n\t\t      t    = r && r[typeof item],\r\n\t\t      node = t && t[<any>item];\r\n\r\n\t\tif(node)\r\n\t\t{\r\n\t\t\tdelete t[<any>item];\r\n\t\t\tconst s = this._set;\r\n\t\t\tif(s && s.removeNode(node))\r\n\t\t\t{\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t}\r\n\r\n}\r\n\r\nfunction wipe(map:IMap<any>, depth:number = 1):void\r\n{\r\n\tif(map && depth)\r\n\t{\r\n\t\tfor(let key of Object.keys(map))\r\n\t\t{\r\n\t\t\tlet v = map[key];\r\n\t\t\tdelete map[key];\r\n\t\t\twipe(v, depth - 1);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default HashSet;"]}