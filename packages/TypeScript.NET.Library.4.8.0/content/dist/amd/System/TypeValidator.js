define(["require","exports","./Types","./Compare","../extends"],function(e,t,r,n,i){"use strict";function s(e,t){if(!n.areEqual(e,t)){var r=new a(e);if(!r.contains(t))return!0}return!1}Object.defineProperty(t,"__esModule",{value:!0});var u=i["default"],a=function(e){function t(t){return e.call(this,t,function(e){return e._value=t})||this}return u(t,e),t.prototype.contains=function(e){var t=this._value;if(t===e)return!0;switch(e){case Function:return this.isFunction;case Object:return this.isObject;case Array:return this.isArray;case String:return this.isString;case Number:return this.isNumber;case Boolean:return this.isBoolean}if(this.type!=typeof e||this.isPrimitive&&!n.areEqual(t,e))return!1;if(this.isArray&&r.Type.isArrayLike(e)){for(var i=Math.min(e.length,t.length),u=0;u<i;u++)if(s(t[u],e[u]))return!1;return!0}if(this.isObject){var a=Object.keys(t),o=Object.keys(e);if(o.length>a.length)return!1;for(var c=0,f=o;c<f.length;c++){var h=f[c];if(a.indexOf(h)==-1)return!1}for(var l=0,p=o;l<p.length;l++){var h=p[l];if(s(t[h],e[h]))return!1}}return!0},t}(r.TypeInfo);t.TypeInfoHelper=a;var o=function(){function e(e){this._typeDescriptor=e,Object.freeze(this)}return e.prototype.isSubsetOf=function(e){return new a(e).contains(this._typeDescriptor)},e}();t.TypeValidator=o,t["default"]=o});
//# sourceMappingURL=TypeValidator.js.map