{"version":3,"sources":["System/Threading/deferImmediate.js","System/Threading/deferImmediate.ts"],"names":["define","require","exports","Types_1","LinkedNodeList_1","Queue_1","ObjectPool_1","Environment_1","flush","entry","immediateQueue","first","task","domain","context_1","context","args","canceller","enter","runSingle","laterQueue","tryDequeue","flushing","params","apply","e","isNodeJS","exit","setTimeout","requestFlush","requestTick","deferImmediate","entryPool","take","process","slice","r","Boolean","removeNode","add","addNode","cancel","dispose","runAfterDeferred","enqueue","Object","defineProperty","value","LinkedNodeList","Queue","ObjectPool","o","length","nextTick","setImmediate","Type","FUNCTION","window","UNDEFINED","bind","MessageChannel","channel_1","port1","onmessage","requestPortTick_1","port2","postMessage"],"mappings":"AAAAA,QAAQ,UAAW,UAAW,WAAY,gCAAiC,uBAAwB,2BAA4B,kBAAmB,SAAUC,EAASC,EAASC,EAASC,EAAkBC,EAASC,EAAcC,GAC5N,YC2CJ,SAAAC,KAIC,IADA,GAAIC,GACEA,EAAQC,EAAeC,OAC7B,CACM,GAAAC,GAAAH,EAAAG,KAAMC,EAAAJ,EAAAI,OAAQC,EAAAL,EAAAM,QAASC,EAAAP,EAAAO,IAC5BP,GAAMQ,YACHJ,GAAQA,EAAOK,QAClBC,EAAUP,EAAMC,EAAQC,EAASE,GAGlC,KAAMI,EAAWC,WAAW,SAAAT,GAC3BO,EAAUP,OAIXU,GAAW,EAsBZ,QAAAH,GAAmBP,EAAeC,EAAiBE,EAAcQ,GAEhE,IAECX,EAAKY,MAAMT,EAASQ,GAErB,MAAME,GAEL,GAAGlB,EAAAmB,SAkBF,KAVGb,IAEFA,EAAOc,OAERC,WAAWpB,EAAO,GACfK,GAEFA,EAAOK,QAGFO,CAONG,YAAW,WAEV,KAAMH,IACJ,GAIFZ,GAEFA,EAAOc,OAIT,QAAAE,KAEKP,IAEHA,GAAW,EACXQ,KAgBF,QAAAC,GAA+BnB,EAAuBG,EAAcC,GAEnE,GAAIP,GAAwBuB,EAAUC,MAiBtC,OAhBAxB,GAAMG,KAAOA,EACbH,EAAMI,OAASN,EAAAmB,UAAkBQ,QAAiB,OAClDzB,EAAMM,QAAUA,EAChBN,EAAMO,KAAOA,GAAQA,EAAKmB,QAC1B1B,EAAMQ,UAAY,WAEjB,IAAIR,EAAO,OAAO,CAClB,IAAI2B,GAAIC,QAAQ3B,EAAe4B,WAAW7B,GAE1C,OADAuB,GAAUO,IAAI9B,GACP2B,GAGR1B,EAAe8B,QAAQ/B,GAEvBoB,KAGCY,OAAQhC,EAAMQ,UACdyB,QAAS,WAAOjC,GAASA,EAAMQ,cAQjC,QAAA0B,GAAiC/B,GAEhCQ,EAAWwB,QAAQhC,GACnBiB,IDpLGgB,OAAOC,eAAe5C,EAAS,cAAgB6C,OAAO,GCmC1D,IAAIjB,GACAR,GAAmB,EA4BjBZ,EAAiB,GAAIN,GAAA4C,eAGrB5B,EAAa,GAAIf,GAAA4C,MAEjBjB,EAAY,GAAI1B,GAAA4C,WAA4B,GACjD,WAAM,UACN,SAACC,GAEAA,EAAEvC,KAAO,KACTuC,EAAEtC,OAAS,KACXsC,EAAEpC,QAAU,KACToC,EAAEnC,OAAMmC,EAAEnC,KAAKoC,OAAS,GAC3BD,EAAEnC,KAAO,KACTmC,EAAElC,UAAY,MAyGhB,IAnCAf,EAAA6B,eAAAA,EA6BA7B,EAAAyC,iBAAAA,EAMGpC,EAAAmB,SAEFI,EAAc,WAEbI,QAAQmB,SAAS7C,QAId,UAAU8C,gBAAenD,EAAAoD,KAAKC,SAKjC1B,QAFS2B,UAAStD,EAAAoD,KAAKG,UAETJ,aAAaK,KAAKF,OAAQjD,GAI1B,WAEb8C,aAAa9C,QAKX,UAAUoD,kBAAiBzD,EAAAoD,KAAKG,UACrC,CAGC,GAAMG,GAAU,GAAID,eAGpBC,GAAQC,MAAMC,UAAY,WAEzBjC,EAAckC,EACdH,EAAQC,MAAMC,UAAYvD,EAC1BA,IAED,IAAIwD,GAAkB,WAIrBH,EAAQI,MAAMC,YAAY,GAE3BpC,GAAc,WAEbF,WAAWpB,EAAO,GAClBwD,SAODlC,GAAc,WAEbF,WAAWpB,EAAO,GAIpBN,GAAAA,WAAe6B","file":"deferImmediate.js","sourcesContent":["define([\"require\", \"exports\", \"../Types\", \"../Collections/LinkedNodeList\", \"../Collections/Queue\", \"../Disposable/ObjectPool\", \"../Environment\"], function (require, exports, Types_1, LinkedNodeList_1, Queue_1, ObjectPool_1, Environment_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var requestTick;\n    var flushing = false;\n    // Use the fastest possible means to execute a task in a future turn\n    // of the event loop.\n    function flush() {\n        /* jshint loopfunc: true */\n        var entry;\n        while (entry = immediateQueue.first) {\n            var task = entry.task, domain = entry.domain, context_1 = entry.context, args = entry.args;\n            entry.canceller();\n            if (domain)\n                domain.enter();\n            runSingle(task, domain, context_1, args);\n        }\n        while (laterQueue.tryDequeue(function (task) {\n            runSingle(task);\n        })) { }\n        flushing = false;\n    }\n    // linked list of tasks.  Using a real linked list to allow for removal.\n    var immediateQueue = new LinkedNodeList_1.LinkedNodeList();\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = new Queue_1.Queue();\n    var entryPool = new ObjectPool_1.ObjectPool(40, function () { return ({}); }, function (o) {\n        o.task = null;\n        o.domain = null;\n        o.context = null;\n        if (o.args)\n            o.args.length = 0;\n        o.args = null;\n        o.canceller = null;\n    });\n    function runSingle(task, domain, context, params) {\n        try {\n            task.apply(context, params);\n        }\n        catch (e) {\n            if (Environment_1.isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n                throw e;\n            }\n            else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n        if (domain) {\n            domain.exit();\n        }\n    }\n    function requestFlush() {\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    }\n    //noinspection JSValidateJSDoc\n    /**\n     *\n     * @param task\n     * @param context\n     * @param args\n     * @returns {{cancel: (()=>boolean), dispose: (()=>undefined)}}\n     */\n    function deferImmediate(task, context, args) {\n        var entry = entryPool.take();\n        entry.task = task;\n        entry.domain = Environment_1.isNodeJS && process['domain'];\n        entry.context = context;\n        entry.args = args && args.slice();\n        entry.canceller = function () {\n            if (!entry)\n                return false;\n            var r = Boolean(immediateQueue.removeNode(entry));\n            entryPool.add(entry);\n            return r;\n        };\n        immediateQueue.addNode(entry);\n        requestFlush();\n        return {\n            cancel: entry.canceller,\n            dispose: function () { entry && entry.canceller(); }\n        };\n    }\n    exports.deferImmediate = deferImmediate;\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    function runAfterDeferred(task) {\n        laterQueue.enqueue(task);\n        requestFlush();\n    }\n    exports.runAfterDeferred = runAfterDeferred;\n    if (Environment_1.isNodeJS) {\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n    }\n    else if (typeof setImmediate === Types_1.Type.FUNCTION) {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== Types_1.Type.UNDEFINED) {\n            requestTick = setImmediate.bind(window, flush);\n        }\n        else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n    }\n    else if (typeof MessageChannel !== Types_1.Type.UNDEFINED) {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel_1 = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel_1.port1.onmessage = function () {\n            requestTick = requestPortTick_1;\n            channel_1.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick_1 = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel_1.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick_1();\n        };\n    }\n    else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    exports.default = deferImmediate;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on code from: https://github.com/kriskowal/q\r\n */\r\nimport {Type} from \"../Types\";\r\nimport {LinkedNodeList} from \"../Collections/LinkedNodeList\";\r\nimport {Queue} from \"../Collections/Queue\";\r\nimport {Closure} from \"../FunctionTypes\";\r\nimport {ILinkedNode} from \"../Collections/ILinkedListNode\";\r\nimport {ICancellable} from \"./ICancellable\";\r\nimport {ObjectPool} from \"../Disposable/ObjectPool\";\r\nimport {isNodeJS} from \"../Environment\";\r\n\r\ndeclare module process\r\n{\r\n\texport function nextTick(callback:Closure):void;\r\n\r\n\texport function toString():string;\r\n}\r\n\r\ninterface IDomain\r\n{\r\n\tenter():void;\r\n\texit():void;\r\n}\r\n\r\ninterface ITaskQueueEntry extends ILinkedNode<ITaskQueueEntry>\r\n{\r\n\ttask:Function;\r\n\tdomain?:IDomain;\r\n\tcontext?:any;\r\n\targs?:any[];\r\n\tcanceller:()=>boolean;\r\n}\r\n\r\n\r\nlet requestTick:()=>void;\r\nlet flushing:boolean = false;\r\n\r\n// Use the fastest possible means to execute a task in a future turn\r\n// of the event loop.\r\n\r\n\r\nfunction flush():void\r\n{\r\n\t/* jshint loopfunc: true */\r\n\tlet entry:ITaskQueueEntry|null;\r\n\twhile(entry = immediateQueue.first)\r\n\t{\r\n\t\tlet {task, domain, context, args} = entry;\r\n\t\tentry.canceller();\r\n\t\tif(domain) domain.enter();\r\n\t\trunSingle(task, domain, context, args);\r\n\t}\r\n\r\n\twhile(laterQueue.tryDequeue(task=>{\r\n\t\trunSingle(task);\r\n\t})){}\r\n\r\n\r\n\tflushing = false;\r\n}\r\n\r\n\r\n// linked list of tasks.  Using a real linked list to allow for removal.\r\nconst immediateQueue = new LinkedNodeList<ITaskQueueEntry>();\r\n\r\n// queue for late tasks, used by unhandled rejection tracking\r\nconst laterQueue = new Queue<Closure>();\r\n\r\nconst entryPool = new ObjectPool<ITaskQueueEntry>(40,\r\n\t() => <any>{},\r\n\t(o:any) =>\r\n\t{\r\n\t\to.task = null;\r\n\t\to.domain = null;\r\n\t\to.context = null;\r\n\t\tif(o.args) o.args.length = 0;\r\n\t\to.args = null;\r\n\t\to.canceller = null;\r\n\t});\r\n\r\nfunction runSingle(task:Function, domain?:IDomain, context?:any, params?:any[]):void\r\n{\r\n\ttry\r\n\t{\r\n\t\ttask.apply(context, params);\r\n\t}\r\n\tcatch(e)\r\n\t{\r\n\t\tif(isNodeJS)\r\n\t\t{\r\n\t\t\t// In node, uncaught exceptions are considered fatal errors.\r\n\t\t\t// Re-throw them synchronously to interrupt flushing!\r\n\r\n\t\t\t// Ensure continuation if the uncaught exception is suppressed\r\n\t\t\t// listening \"uncaughtException\" events (as domains does).\r\n\t\t\t// Continue in next event to avoid tick recursion.\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.exit();\r\n\t\t\t}\r\n\t\t\tsetTimeout(flush, 0);\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.enter();\r\n\t\t\t}\r\n\r\n\t\t\tthrow e;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// In browsers, uncaught exceptions are not fatal.\r\n\t\t\t// Re-throw them asynchronously to avoid slow-downs.\r\n\t\t\tsetTimeout(()=>\r\n\t\t\t{\r\n\t\t\t\tthrow e;\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tif(domain)\r\n\t{\r\n\t\tdomain.exit();\r\n\t}\r\n}\r\n\r\nfunction requestFlush():void\r\n{\r\n\tif(!flushing)\r\n\t{\r\n\t\tflushing = true;\r\n\t\trequestTick();\r\n\t}\r\n}\r\n\r\n\r\n\r\nexport function deferImmediate(task:Closure, context?:any):ICancellable\r\nexport function deferImmediate(task:Function, context?:any, args?:any[]):ICancellable\r\n//noinspection JSValidateJSDoc\r\n/**\r\n *\r\n * @param task\r\n * @param context\r\n * @param args\r\n * @returns {{cancel: (()=>boolean), dispose: (()=>undefined)}}\r\n */\r\nexport function deferImmediate(task:Closure|Function, context?:any, args?:any[]):ICancellable\r\n{\r\n\tlet entry:ITaskQueueEntry = entryPool.take();\r\n\tentry.task = task;\r\n\tentry.domain = isNodeJS && (<any>process)['domain'];\r\n\tentry.context = context;\r\n\tentry.args = args && args.slice();\r\n\tentry.canceller = ()=>\r\n\t{\r\n\t\tif(!entry) return false;\r\n\t\tlet r = Boolean(immediateQueue.removeNode(entry));\r\n\t\tentryPool.add(entry);\r\n\t\treturn r;\r\n\t};\r\n\r\n\timmediateQueue.addNode(entry);\r\n\r\n\trequestFlush();\r\n\r\n\treturn {\r\n\t\tcancel: entry.canceller,\r\n\t\tdispose: ()=> { entry && entry.canceller(); }\r\n\t}\r\n}\r\n\r\n\r\n// runs a task after all other tasks have been run\r\n// this is useful for unhandled rejection tracking that needs to happen\r\n// after all `then`d tasks have been run.\r\nexport function runAfterDeferred(task:Closure):void\r\n{\r\n\tlaterQueue.enqueue(task);\r\n\trequestFlush();\r\n}\r\n\r\nif(isNodeJS)\r\n{\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tprocess.nextTick(flush);\r\n\t};\r\n\r\n}\r\nelse if(typeof setImmediate===Type.FUNCTION)\r\n{\r\n\t// In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\r\n\tif(typeof window!==Type.UNDEFINED)\r\n\t{\r\n\t\trequestTick = setImmediate.bind(window, flush);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trequestTick = ()=>\r\n\t\t{\r\n\t\t\tsetImmediate(flush);\r\n\t\t};\r\n\t}\r\n\r\n}\r\nelse if(typeof MessageChannel!==Type.UNDEFINED)\r\n{\r\n\t// modern browsers\r\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\r\n\tconst channel = new MessageChannel();\r\n\t// At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\r\n\t// working message ports the first time a page loads.\r\n\tchannel.port1.onmessage = function()\r\n\t{\r\n\t\trequestTick = requestPortTick;\r\n\t\tchannel.port1.onmessage = flush;\r\n\t\tflush();\r\n\t};\r\n\tlet requestPortTick = ()=>\r\n\t{\r\n\t\t// Opera requires us to provide a message payload, regardless of\r\n\t\t// whether we use it.\r\n\t\tchannel.port2.postMessage(0);\r\n\t};\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t\trequestPortTick();\r\n\t};\r\n\r\n}\r\nelse\r\n{\r\n\t// old browsers\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t};\r\n}\r\n\r\nexport default deferImmediate;"]}